# 渲染管线

## Vertex Shader

### 坐标变换

* **局部坐标 -> 世界坐标**

  顶点坐标乘以模型矩阵变换到世界空间

  平移、旋转、缩放、错切、刚体（平移和旋转的级联）、法线变换https://blog.csdn.net/shenghuaDay/article/details/73611392?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-2&spm=1001.2101.3001.4242

* **世界坐标 -> 观察坐标**

  观察矩阵（摄像机位置、目标点、向上的方向向量）

* **观察坐标 -> 裁剪坐标**

  投影矩阵（正交投影、透视投影）

* 裁剪坐标 -> 标准设备空间（NDC）

  透射除法

* NDC -> 窗口坐标
  视口变换
## 曲面细分着色器

* 可选阶段

* 由外壳着色器、镶嵌器和域着色器组成，用于增加三角面片数量

## 几何着色器
* 可选阶段
* 创建和销毁几何图元 将一个顶点扩展两个三角面片
## 图元组装

### 裁剪

部分位于视锥体内的图元，需要进行裁剪

* **Cohen-Sutherland算法（线段裁剪算法）**

  线段裁剪，对窗口周围和窗口分为九个位置区域，进行四位编码，0000，0001，... 然后对线段的两顶点进行&运算，得到0就保留，有1就舍去线段。

  缺点：全部舍弃的判断只适合于那些仅在窗口同一侧（后左、或右、或上、或下）的线段。

* **Liang-Barsky算法 （直线线段裁剪算法）**

  上一个算法的改进，https://www.cnblogs.com/cnblog-wuran/p/9813841.html

* **Sutherland-Hodgman多边形裁剪算法**

  只能裁剪凸多边形

  基本思想：一次用窗口的一边裁剪多边形https://blog.csdn.net/qq_40310876/article/details/90742143

### 背面剔除

背面剔除默认是不开启的

利用三角形顶点的环绕顺序来确定正面和背面

三角形的3个顶点是逆时针顺序排列 为正面  顺时针顺序为背面

```c++
glEnable(GL_CULL_FACE) //开启背面剔除
```

### 屏幕映射

* 透视除法

   经过了投影矩阵的变换后，保留了物体z轴坐标的信息，透视除法根据距离摄像机的远近正确实现透视效果。

  由硬件自动执行，无论是透视投影还是正交投影。

* 视口变换

  经过平移和缩放，得到窗口坐标

### 拾取

将窗口坐标转换为观察坐标

求出从原点到点击点的拾取射线

将观察空间的拾取射线变换到局部空间，进行相交检测

## 光栅化

该过程也成为扫描转换，将变换到屏幕空间的图元离散化为片元的过程。

包括两个步骤：三角形的组装和三角形的遍历。

### 线段扫描转换

#### 数字微分画线算法（DDA）

DDA算法的基本思想是对于每个x值，算出一个最佳位置的y值。对于斜率大于1的线段，由于两个像素点之间的间隔过大，生成近似的线段产生了较大的误差。对于斜率大于1的线段，我们可以通过交换x和y，即该算法变为：对于每个y值，计算一个最佳的x值。

#### Bresenhan光栅化算法

记直线与它垂直方向最近的下光栅点的误差为d，有：d=(y+k)–yi，且0≤d≤1
    当d<0.5：下一个象素应取右光栅点(xi+1,yi)
    当d≥0.5：下一个象素应取右上光栅点(xi+1,yi+1)

https://blog.csdn.net/ming1006/article/details/8006769

只需要通过整数的加法、减法和移位操作，效率很高，所以它已经成为 硬件和软件光栅处理器的标准算法。Bresenhan算法与DDA算法的主要区别在于构造了一个新的判定变量d来避免浮点数的运算

### 多边形填充算法

#### 扫描线填充算法

新建立边表，再使用活性边表(AET)从低至高进行更新，每次更新确定扫描线的交点，在交点范围内进行像素点的填充。具体操作如下

https://blog.csdn.net/wodownload2/article/details/52154207

```c++
typedf struct {
    float ymax; //边的最大y坐标
    float x; //交点的x坐标
    float delta; //边的斜率的倒数
    Edge *nextEdge; //下一条边
}Edge;
```

## Fragment Shader

光栅化后，确定了图形的每个像素点的位置，接着通过片段着色器决定每个像素点的颜色。例如光照计算和阴影处理。

### 光照模型

* Lambert漫反射光照模型

  环境光+漫反射

* Phong镜面反射光照模型

  环境光+漫反射+镜面高光

* BlinnPhong光照模型

  环境光+漫反射+半角镜面高光

  https://blog.csdn.net/cuiyh1993/article/details/50349587?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control

### 纹理贴图

凹凸贴图和法线贴图

https://blog.csdn.net/yjr3426619/article/details/81022781

mipmap 多级纹理贴图https://blog.csdn.net/qjh5606/article/details/89040887?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161950821716780264085080%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161950821716780264085080&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-89040887.pc_search_result_no_baidu_js&utm_term=mipmap

### 抗锯齿

* 超级采样抗锯齿 SSAA :  先渲染到四倍面积的缓冲区，再下采样到原屏幕，计算量非常大
* 多重采样抗锯齿 MSAA: 会对每个像素点分配更多的采样点， 根据覆盖率进行着色。

### 阴影（Shadows）

* 静态物体使用Lightmap烘培

  就是把物体光照的明暗信息保存到纹理上， 实施绘制不再进行光照计算

* **动态物体使用Shadowmap**

  从光源位置渲染一遍场景，将深度信息写入到贴图中，然后再一次正常的渲染场景，利用shadowmap判断落在阴影中的区域。

  使用偏移量 解决阴影粉刺

  使用百分比渐进过滤实现软化阴影效果，解决阴影走样的问题。