# C++面试问题

### 1. c++中的四个强制类型转换

* static_cast

  static_cast（静态转换）本质上是c语言强制转换的替代品；

  另外还能用于基类和派生类之间指针或引用的转换；
  \- 进行上行转换（把派生类的指针或引用转换成基类表示），是安全的；
  \- 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的；

```c++
char a = 'a';
int b = static_cast<int>(a);//将char型数据转换成int型数据

//类指针或引用强制转换
Base* bp = new Base();
Derived* dp = static_cast<Derived*>(bp);//下行转换时不安全的

Derived* dp1 = new Derived();
Base* bp1 = static_cast<Base>(dp1);//上行转换时安全的
```

* const_cast

```c++
const int a = 5;
int *p;
p = const_cast<int*>(&a);
```

并没有在真正去除变量的const属性，去除了指针的const属性，间接修改

* dynamic_cast

用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。
* reinterpret_cast

几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；

* 为什么不使用C++的强制转换？444444

C++的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

### 2. C++编译器为类产生的四个缺省函数

* **默认构造函数**

  专门用于初始化成员变量

  **什么时候必须用到初始化成员列表 **：类的成员是常量、是对象且没有无参构造函数、是引用。

  **构造函数的调用顺序：**

  1. 先调用基类构造函数
  2. 按声明顺序初始化数据成员
  3. 最后调用自己的构造函数

  

* **拷贝构造函数**

  ```c++
  class Complex {
  private:
      int x, y;
  public:
      Complex(int x_, int y_) : x(x_), y(y_) {} 
      Complex(const Complex&); //默认的拷贝构造函数
  };
  Complex c1(1,2);
  Complex c2(c1); //1.调用拷贝构造函数  
  Complex c2 = c1; //调用拷贝构造函数  
  //调用拷贝构造函数就不会再调用构造函数
  
  void func(Complex c) {  //2.
      Complex c3(2,2);
      return c3;  //3.
  }
  ```

  1. 当类的一个对象去初始化该类的另一个对象

  2. 当函数的形参是类的对象，调用函数进行形参和实参的结合

  3. 函数的返回值是类的对象，调用函数返回值

  4. **重写拷贝构造函数**

     当构造函数涉及到动态存储分配空间时
     
     

* **析构函数**

  对象生命周期结束时 调用

  **调用顺序与构造函数相反**

  

* **赋值函数**

  系统自定的运算重载符=函数
  
  ```c++
  Complex c1(1,2);
  Complex c2(3,4);
  c2 = c1;
  ```
  
  

### 3. 静态函数存在的意义

* 通过类的静态成员函数访问类的静态私有成员

* 类的构造函数是私有时，只能通过静态成员函数来调用构造函数

* 静态成员函数不具体作用与某个对象，只能访问静态成员，不能访问非静态成员变量

  ```c++
  class C {
  private:
      int w,h;
      static int n1;  //静态成员变量
      static int n2;
  public:
      static void printTotal() {
          cout << n1;
          cout << n2;
      };  //静态成员函数
  };
  
  C::printTotal(); 
  C c1(1,1);
  c1.printTotal();
  ```
  
  

### 4. 基础概念

* **OOP**  的设计思想是 把数据结构和对数据结构进行操作的方法 封装成一个个对象

* **OOP**的三大特征：封装、继承、多态   特征向量

* **类**  是把一些具有共性的对象归类后形成 一个集合

* 在类的内部定义成员函数，会变成**内联函数**，它在函数调用的地方在编译阶段会进行代码替换

* 成员函数通过  **this指针指向对象的首地址**  来区分不同对象的成员数据

* **常对象 ** 是指在任何场合都不能对其成员的值进行修改的对象

* **抽象类**  不用来定义对象 只作为一种基本类型用作继承的类  其会定义纯虚函数

* **运算重载符** 使用户定义数据类型的数据的操作于内定义的一致

  不允许重载的运算符：

  1. .*（成员指针访问运算符号）
  2. ：：域运算符
  3. Sizeof 长度运算符号
  4. ？：条件运算符号
  5. .（成员访问符）
  
* **父类写了virtual函数，子类覆盖它的复写函数，会隐形继承virtual，virtual可加可不加，一样会实现多态。**

* 虚函数的实现使用了虚函数表。

* **回调函数**：预先在系统对函数进行注册，当某个事件发生时，再调用这个函数对事件进行响应。在函数前面加上CALLBACK

* 全局对象的构造函数会在main函数之前执行。

* **实时系统**能在特定时间完成特定的任务， 实时性和可靠性。

* 全局变量存储在静态数据区，局部变量存储在堆栈中。

* **堆栈溢出 是没有回收垃圾资源**。

* switch的参数不能为实型。

* c++不是类型安全的， 两个不同类型的指针可以强制转换（reinterpret_cast）
### 5. 拷贝构造函数与赋值函数对比

* 都是将一个对象copy到另一个对象

* 拷贝构造函数需要新建立一个对象

### 6. 函数重载与虚函数

* **函数重载：**

  一个同名函数完成不同的功能，编译系统在编译阶段通过函数参数个数、类型的不同，函数的返回值来确定调用哪个函数，实现了**静态的多态性**。**不能仅靠返回值的不同来实现函数重载。**

  **构造函数可以重载，析构函数不可以重载。**

  

* **虚函数：**(为了使基类指针 能够访问派生类的成员函数)

  在基类中使用关键字**virtual**申明一个函数为虚函数，含义就 是该函数的功能可能将在某个派生类中定义或者在基类的基础上进行扩展。系统在运行阶段才能动态的决定该调用哪一个函数，实现了**动态的多态性**。

  虚函数有虚拟指针和虚函数表，虚拟指针是虚函数的接口。

  

  **目的**：通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数 进行访问，尤其是成员函数，如果没有多态  只能访问成员变量。
  
  
  
  **注意：虚函数要么设为纯虚函数，要么有定义，要不然无法生成虚函数表。**
  
  声明为纯虚函数，类为抽象类，无法实例化。在虚函数的后面加=0
  
  
  
  **凡是基类定义有虚函数，则基类需要定义虚析构函数（规则如上）**：虚析构函数是为防止析构不彻底，导致内存泄漏。
  
  虚析构函数使得在删除指向子类对象的基类指针时  可以调用子类的析构函数 达到释放子类中堆内存的目的， 从而防止内存泄露。
  
  
  
  **内联函数和构造函数不能为虚函数**：对于基类的构造函数，它仅仅是在派生类构造函数中被调用，派生类并不继承基类的构造函数，将构造函数声明为虚函数没有意义。
  
  
  
  

### 7. 类模板与模板类

* 类模板，是建立一个通用类，其数据成员、成员函数的返回值类型和形参类型不具体指定，用一个虚拟的类型来代表。**使用类模板定义对象时，系统会实参的类型来取代类模板中虚拟类型从而实现了不同类的功能**。

* 类模板的派生一定是类模板

  ```c++
  template<tyname T>
  class Compare {
  public:
      Compare(T i, T j) {
          x = i;
          y = j;
      }
  private:
      T x, y;
  }; //这是一个类模板
  
  Compare<int>com1(3,7); //Compare<int>是模板类
  ```

  

* 模板类是类模板实例化的的一个产物。

* 模板类可以派生新的模板类，也可以派生非模板类

### 8. 当一个类A 中没有生命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零

* 肯定不是零。举个反例，如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分A[0],A[1]…了。

### 9. delete 与 delete[]的区别

* delete只会调用一次析构函数，delete[]会调用每个成员的析构函数。

* 子类析构时 会调用父类的析构函数

  次序是先派生后基类

###   10. 继承的优缺点

* 优点：
  1、类继承是在编译时刻静态定义的，且可直接使用，
  2、类继承可以较方便地改变父类的实现。

* 缺点：
  1、因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现
  2、父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为
  3、如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。

### 11. 堆和栈

* **stack**

  **由编译器自动分配释放,  存放函数的参数值,  局部变量的值等**

* **heap**

  一般由程序员分配释放,  若不手动释放, 程序结束由OS回收

### 12. 何时需要预编译

* 总是使用的不经常改动的大型代码体

* 程序由多模块组成，所有模块都使用一组标准的包含文件和相同的编译选项

### 13.  多态的作用

* 隐藏实现细节，代码模块化；扩展代码模块，实现代码重用；

* 接口重用：为了类在继承和派生的时候， 使用家族中任意一类的实例的某一属性的正确调用

### 14. 常引用

* 如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。

### 15. 引用和指针的区别

* 引用必须初始化，指针不用
* 引用初始化不能被改变，指针可以改变所指的对象
* 不存在指向空值的引用，存在指向空值的指针

### 16. 如何引用一个已经定义过的全局变量

* 可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错

### 17. 数组和指针的区别

* 数组要么在静态存储区，要么在栈上被创建。指针可以随时指向任意类型的内存块。

### 18. 内存的分配方式

* 静态存储区，程序编译时分配好了，全局变量和常量。

* 栈上分配，局部变量，内存有限。

* 堆上分配，也称动态分配， new,malloc分配内存，delete,free释放内存

  ```c++
  int *p = new int(); 
  delete p;
  
  int *p = new int[len];
  delete []p;
  
  vector<vector<int>> arr(n, vector<int>(m));
  
  myClass *p = new myClass[len];
  delete []p;
  ```

  

### 19. 四个智能指针

* 智能指针是一个类对象，负责自动释放所指向的对象。

* **auto_ptr**已弃用

  避免因潜在的内存问题导致程序崩溃

* **unique_ptr**（替代auto_ptr）

  禁止了拷贝语义，提供了移动语义  将所有权从原本的指针转移到新指针

  ```c++
  //将所有权从p1（指向string Stegosaurus）转移给p2
  unique_ptr<string> p2(p1.release());//release将p1置为空
  unique_ptr<string> p3(new string("Trex"));
  //将所有权从p3转移到p2
  p2.reset(p3.release());//reset释放了p2原来指向的内存
  ```

  

* **shared_ptr**

  引用计数型智能指针

  引用计数变为0时，会自动释放管理的对象

* **weak_ptr**

  辅助shared_ptr
  
  用于判断shared_ptr是否指向某个对象

### 20. 怎么消除多重继承中的二义性

* 成员限定符
* 虚基类 在继承基类前加virtual
* http://c.biancheng.net/view/2280.html
* 虚继承的目的是让某个类作出声明，承诺愿意共享它的基类，被共享的基类成为虚基类

### 21. 派生新类的三个步骤

* 吸收基类成员
* 改造基类成员
* 添加新成员

### 22. 类的声明和实现的分开的好处

* 起保护作用
* 提高编译的效率

### 23. unordered_map 与 unordered_set 的区别

* 两者都是基于hashtable

### 24. #include<filename.h> 和 #include "filename.h"

* 编译器从标准库路径开始搜索

* 编译器从用户的工作路径开始搜索

### 25. static的应用和作用

* 函数体内的static 变量的作用范围为该函数体， 不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值。

  ```c++
  void function() {
      int a = 5;
      auto int b = 7;  //a与b 都为自动变量 当funciton被调用时，a和b的值都会压入栈，函数开始执行时，自动变量a和b都与栈内对应的值关联起来，函数调用结束后，栈顶指针回到压栈前的位置。 
  }
  
  //静态变量 有三种形式
  int g_value = 100; //外部链接  静态变量 （其他文件可以访问） extren int g_value
  static int f_value = 200; //内部链接  静态变量 （只在本文件中访问）
  
  void function1() {
      static int in_value = 300; //静态变量  无链接（只能在当前函数或代码块中访问）
  }
  ```

* 模块内的static变量和函数的作用域 只在本模块内

* 类中的static成员变量属于整个类所拥有， 对类的所有对象只有一份拷贝

* 类中的static成员函数属于整个类所拥有， 这个函数不接受this指针， 因而只能访问类的static成员变量。

