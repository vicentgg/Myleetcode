# C++面试问题

### 1. c++中的四个强制类型转换

* static_cast

  static_cast（静态转换）本质上是c语言强制转换的替代品；

  另外还能用于基类和派生类之间指针或引用的转换；
  \- 进行上行转换（把派生类的指针或引用转换成基类表示），是安全的；
  \- 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的；

```c++
char a = 'a';
int b = static_cast<int>(a);//将char型数据转换成int型数据

//类指针或引用强制转换
Base* bp = new Base();
Derived* dp = static_cast<Derived*>(bp);//下行转换时不安全的

Derived* dp1 = new Derived();
Base* bp1 = static_cast<Base>(dp1);//上行转换时安全的
```

* const_cast

```c++
const int a = 5;
int *p;
p = const_cast<int*>(&a);
```

并没有在真正去除变量的const属性，去除了指针的const属性，间接修改

* dynamic_cast

用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。
* reinterpret_cast

几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；

* 为什么不使用C++的强制转换？

C++的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

### 2. C++编译器为类产生的四个缺省函数

* 默认构造函数

  专门用于初始化成员变量

  **什么时候必须用到初始化成员列表 **：类的成员是常量、是对象且没有无参构造函数、是引用。

  **构造函数的调用顺序：**

  1. 先调用基类构造函数
  2. 按声明顺序初始化数据成员
  3. 最后调用自己的构造函数

  

* 拷贝构造函数

  1. 当类的一个对象去初始化该类的另一个对象

  2. 当函数的形参是类的对象，调用函数进行形参和实参的结合

  3. 函数的返回值是类的对象，调用函数返回值

  4. **重写拷贝构造函数**

     当构造函数涉及到动态存储分配空间时
     
     

* 析构函数

  对象生命周期结束时 调用

  **调用顺序与构造函数相反**

  

* 赋值函数：

  系统自定的运算重载符=函数

### 3. 静态函数存在的意义

* 通过类的静态成员函数访问类的静态私有成员
* 类的构造函数是私有时，只能通过静态成员函数来调用构造函数

### 4. 基础概念

* **OOP**  的设计思想是 把数据结构和对数据结构进行操作的方法 封装成一个个对象

* **类**  是把一些具有共性的对象归类后形成 一个集合

* 在类的内部定义成员函数，会变成**内联函数**，它在函数调用的地方在编译阶段会进行代码替换

* 成员函数通过  **this指针指向对象的首地址**  来区分不同对象的成员数据

* **常对象 ** 是指在任何场合都不能对其成员的值进行修改的对象

* **抽象类**  不用来定义对象 只作为一种基本类型用作继承的类  其会定义纯虚函数

* **运算重载符** 使用户定义数据类型的数据的操作于内定义的一致

  不允许重载的运算符：

  1. .*（成员指针访问运算符号）
  2. ：：域运算符
  3. Sizeof 长度运算符号
  4. ？：条件运算符号
  5. .（成员访问符）
  
* **父类写了virtual函数，子类覆盖它的复写函数，会隐形继承virtual，virtual可加可不加，一样会实现多态。**

* 虚函数的实现使用了虚函数表。

* **回调函数**：预先在系统对函数进行注册，当某个事件发生时，再调用这个函数对事件进行响应。在函数前面加上CALLBACK

* 全局对象的构造函数会在main函数之前执行。

* **实时系统**能在特定时间完成特定的任务， 实时性和可靠性。

* 全局变量存储在静态数据区，局部变量存储在堆栈中。

* **堆栈溢出 是没有回收垃圾资源**。

* switch的参数不能为实型。

* c++不是类型安全的， 两个不同类型的指针可以强制转换（reinterpret_cast）
### 5. 拷贝构造函数与赋值函数对比

* 都是将一个对象copy到另一个对象

* 拷贝构造函数需要新建立一个对象

### 6. 函数重载与虚函数

* **函数重载：**

  一个同名函数完成不同的功能，编译系统在编译阶段通过函数参数个数、类型的不同，函数的返回值来确定调用哪个函数，实现了**静态的多态性**。**不能仅靠返回值的不同来实现函数重载。**

  **构造函数可以重载，析构函数不可以重载。**

* **虚函数：**

  在基类中使用关键字**virtual**申明一个函数为虚函数，含义就 是该函数的功能可能将在某个派生类中定义或者在基类的基础上进行扩展。系统在运行阶段才能动态的决定该调用哪一个函数，实现了**动态的多态性**。

  

  **注意：虚函数要么设为纯虚函数，要么有定义，要不然无法生成虚函数表。**

  声明为纯虚函数，类为抽象类，无法实例化。在虚函数的后面加=0
  
  **凡是基类定义有虚函数，则基类需要定义虚析构函数（规则如上）**：虚析构函数是为防止析构不彻底，导致内存泄漏。
  
  虚函数有虚拟指针和虚函数表，虚拟指针是虚函数的接口。
  
  **内联函数和构造函数不能为虚函数**
  
  

### 7. 类模板与模板类

* 类模板，是建立一个通用类，其数据成员、成员函数的返回值类型和形参类型不具体指定，用一个虚拟的类型来代表。**使用类模板定义对象时，系统会实参的类型来取代类模板中虚拟类型从而实现了不同类的功能**。

* 类模板的派生一定是类模板

  ```c++
  template<tyname T>
  class Compare {
  public:
      Compare(T i, T j) {
          x = i;
          y = j;
      }
  private:
      T x, y;
  }; //这是一个类模板
  
  Compare<int>com1(3,7); //Compare<int>是模板类
  ```

  

* 模板类是类模板实例化的的一个产物。

* 模板类可以派生新的模板类，也可以派生非模板类

### 8. 当一个类A 中没有生命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零

* 肯定不是零。举个反例，如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分A[0],A[1]…了。

### 9. delete 与 delete[]的区别

* delete只会调用一次析构函数，delete[]会调用每个成员的析构函数。

* 子类析构时 会调用父类的析构函数

  次序是先派生后基类

###   10. 继承的优缺点

* 优点：
  1、类继承是在编译时刻静态定义的，且可直接使用，
  2、类继承可以较方便地改变父类的实现。

* 缺点：
  1、因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现
  2、父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为
  3、如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。

### 11. 堆和栈

* **stack**

  **由编译器自动分配释放,  存放函数的参数值,  局部变量的值等**

* **heap**

  一般由程序员分配释放,  若不手动释放, 程序结束由OS回收

### 12. 何时需要预编译

* 总是使用的不经常改动的大型代码体

* 程序由多模块组成，所有模块都使用一组标准的包含文件和相同的编译选项

### 13.  多态的作用

* 隐藏实现细节，代码模块化；扩展代码模块，实现代码重用；

* 接口重用：为了类在继承和派生的时候， 使用家族中任意一类的实例的某一属性的正确调用
  

### 14. 常引用

* 如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。

### 15. 引用和指针的区别

* 引用必须初始化，指针不用
* 引用初始化不能被改变，指针可以改变所指的对象
* 不存在指向空值的引用，存在指向空值的指针

### 16. 如何引用一个已经定义过的全局变量

* 可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错

### 17. 数组和指针的区别

* 数组要么在静态存储区，要么在栈上被创建。指针可以随时指向任意类型的内存块。

### 18. 内存的分配方式

* 静态存储区，程序编译时分配好了，全局变量和常量。
* 栈上分配，局部变量，内存有限。
* 堆上分配，也称动态分配， new,malloc分配内存，delete,free释放内存