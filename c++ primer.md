### 变量与对象
#### 对象的定义

指一块能存储数据并具有某种类型的内存空间

#### 初始化

初始化不是赋值，其含义是创建变量时赋予一个初始值，而赋值的含义是把对象的当前值擦除，而用一个新值替代。

```c++
int x = 0; int x(0); int x{0}; int x = {0};
```

定义于函数体内的内置类型的对象如果没有初始化,  则其值未定义.

类的对象没有显示的初始化,其值由类确定.

#### 声明变量

```c++
extern int i;//声明i
int j; //声明并定义j
```

变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。变量能且只能被定义一次，但是可以被多次声明。声明和定义的区别看起来也许微不足道，但实际上却非常重要。如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。

#### 复合类型

是基于其他类型定义的类型

#### 引用

定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。

引用即别名，引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。

**因为引用本身不是一个对象，所以不能定义引用的引用。**

而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起

```
int y = 0; int &x = y;
```

#### 指针

指针本身是一个对象,   允许对指针进行赋值和拷贝,   而且在指针的生命周期内它可以先后指向几个不同的对象。

指针无须在定义时赋初值

```c++
int val = 42; int *p = &val;  //不能定义指向引用的指针  因为引用没有实际地址
```

```c++
int i = 42;
int &r = i;  //r是一个引用
int *p;      //p是一个指针
p = &i;      //&是取址符
*p = i;      //*是解引用符
int &r2 = *p;//&是声明的一部分 *是解引用符
int *p = &r; //p是指针 &是取值符
```

```c++
int *p = nullptr; // 初始化空指针
```

```c++
int* p1,p2; //p1是指向int的指针,p2是int
int *p1, *p2; //p1和p2都是指向int的指针
```

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用

```c++
int i = 42;
int *p;       //p是一个int型指针
int *&r = p;  //r是一个对指针p的引用

r = &i;       //令p指向i
*r = 0;       //将i的值改为0
```

#### const对象

const对象初始化时 必须赋值

如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。

```c++
const int ci = 1024;
const int &c1 = ci;   //常量引用  不能对常量引用进行修改
```

指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。

```c++
int i = 0;
int *const p1 = &i; //常量指针p1 不能改变p1的值  顶层const
const int ci = 42;  //不能改变ci值  顶层const
const int *p2 = &ci; //可以改变p2的值 底层const

const int *const p3 = p2;  //
const int &r = ci;     //用于声明引用的const都是底层const
```

#### 类型别名

```c++
typedef double wages; // wages是double的同义词
using SI = Sales_item;  // SI是Sales_item的同义词
```

#### auto类型说明符

#### decltype类型指示符

```c++
auto v = v1 + v2;
decltype(f()) sum = x;  //sum的类型就是函数f的返回类型
```

不调用函数f,  而是使用当调用发生时f的返回值类型作为sum的类型

#### 预处理器

确保头文件多次包含仍能安全工作的常用技术

预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。之前已经用到了一项预处理功能#include，当预处理器看到#include标记时就会用指定的头文件的内容代替#include。

#### 头文件保护符

预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。

```c++
#ifndef SA
#define SA
...
...
#endif
```

### 字符串、向量和数组

#### string

* 初始化

  ```c++
  string s(10, 'c'); //内容cccccccccc
  string s("value");
  ```

* 操作

  ```c++
  #include<cctype>
  using namespace std;
  char c;
  isalnum(c); //数字或字母
  isalpha(c); //字母
  isdigit(c); //数字
  islower(c); //小写
  isupper(c); //大写
  tolower(c); //改为小写
  toupper(c); //改为大写
  
  //遍历
  for(auto c : str) 
      cout << c << endl;
  ```

#### vector

vector是模板 并非类型

* 初始化

  ```c++
  vector<T> v1; //空
  vector<T> v2(v1); //v2包含v1的副本
  vector<T> v2 = v1;
  vector<T> v3(n, val);
  vector<T> v4(n);
  vector<T> v5{a,b,c ...}
  vector<T> v5 = {a,b,c ...}
  ```

  

#### 数组

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值

