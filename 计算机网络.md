# 计算机网络高频题

### 1. 网络协议分层

* 网络协议是计算机在通信过程中要遵循的一些约定好的规则

* 网络分层的原因：

  易于实现和维护，因为各层之间是独立的，层与层之间不会收到影响。

  有利于标准化的制定。 
### 2. 计算机网络模型

* 应用层：

  通过应用进程之间的交互来完成特定的网络作用，应用层协议有域名系统DNS，HTTP协议，FTP协议

* 表示层

  表示层的主要作用是数据的表示、安全、压缩。确保一个系统的应用层发送的消息可以被另一个系统的应用层读取。

* 会话层  

  会话层的主要作用是建立通信链接，保持会话过程中的畅通。

* 传输层：

  主要作用是负责向两台主机进程之间的通信提供数据传输服务，传输层协议有传输控制协议TCP和用户数据协议UDP

* 网络层：

  主要作用是选择合适的网间路由和交换结点，确保数据及时送达。IP协议  ARP协议

* 数据链路层：

  在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧在信道上无差错的传输并进行各电路上的动作系列。

* 物理层：

  实现相邻计算机之间比特流的透明传输，并尽量屏蔽具体传输介质和物理设备的差异。



OSI七层模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

五层协议：应用层、传输层、网络层、数据链路层、物理层

TCP/IP四层协议：应用层、传输层、网络层、网络接口层



**端口号：** 不同计算机中的进程进行通信时，需要指定一个统一的标准，来识别不同主机中的不同进程。引入端口号的概念，用于标识可以实现某特定功能的进程。 这是软件端口。  而硬件端口是不同硬件设备间交互的接口。

操作系统底层用16位4字节大小来表示端口号，这样最多就可以表示65535个端口号。

服务器端口号：

1. 知名端口号0~1023

   HTTPs：443

   FTP：21

   SSH：22

   telnet：23

2. 登记端口号 1024~49151

   自己编写的具备某特定功能的服务器，就可以在这个数值范围内申请一个端口号来绑定该服务器进程

客户端端口号：49152~65535

是由操作系统动态分配，因为一个客户端在向服务发送完请求之后，收到回应之后，该客户端进程就终止了，它所对应的端口号也就不复存在了，这个端口号就可以给其他进程继续使用。当下次在运行时，可以为其分配新的端口号。因此为客户端指定固定的端口号是没有意义的，因为它不向服务器一样要一直运行，要被众所周知。


### 3. TCP 三次握手（建立客户端与服务端的连接）

三次握手的本质就是确定发送端和接收端都具备收发消息的能力。

* 客户端 -> 服务端

  客户端向服务端发起建立连接请求

  客户端随即生成序列号seq = x   标志位SYN=1

  客户端状态由closed转为SYN-SEND

* 服务端 -> 客户端

  服务端接收到客户端的报文后

  随机生成序列号seq=y 确认号ack=x+1 标志位SYN=1（要与客户端建立连接） ACK =1（表示确认序号有效）

  服务端状态由LISTEN转化为SYN-RCVD

* 客户端 -> 服务端

  客户端接收到服务端的报文后

  序列号seq=x+1 确认号ack=y+1 标志位ACK =1

  客户端和服务端状态都为ESTABLELISTEN

如果是两次握手，客户端没有收到服务器的确认报文，就会认为服务器没有和他建立连接，而服务器却以为已经建立连接，开始发送数据，造成资源浪费。  或者是服务端接收到已经失效的客户端连接请求报文，会和客户端建立连接，造成资源浪费。

### 4. TCP四次挥手（断开客户端与服务端的连接）

* 客户端->服务端

  客户端向服务端发起释放连接报文

  报文标志位FIN=1 序列号seq=u

  客户端此时只能接收数据 不能发

* 服务端->客户端

  服务端向客户端发送确认报文

  标志位ACK=1 序列号seq=v 确认号ack=u+1

  服务端到客户端的单向连接正常传输数据

* 服务端->客户端

  服务端向客户端发送连接释放报文

  报文标志位FIN=1 标志位ACK=1 序列号seq=w 确认号ack=u+1

* 客户端->服务端

  客户端收到服务端发送的释放连接请求，向服务端发送确认报文

  标志位ACK=1 seq=u+1 确认号ack = w+1

  服务端关闭

  客户端等待2MSL关闭   MSL是报文的最长寿命
  
  * 客户端发送第四次挥手的报文后， 经过2MSL后，使本次TCP连接中的所有报文全部消失， 不会出现在下一个TCP连接中。
  * 如果服务端没有接收到客户端的确认报文，就会重复第三次挥手的报文。如果客户端没有等待直接关闭，就会导致服务端无法正常关闭。

### 5. ARP协议

属于网络层的协议，主要作用是实现从IP地址转为MAC地址。

- IP地址：IP地址是指互联网协议地址，IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。
- MAC地址：MAC地址又称物理地址，由网络设备制造商生产时写在硬件内部，不可更改，并且每个以太网设备的MAC地址都是唯一的。
- IP和MAC地址的必要性：
  1. 只使用IP地址是不可取的， 因为用户可以更改自己的IP地址。
  2. 只使用MAC地址也是不可取的， 因为设备越来越多， 且出现了子网的概念， 对于路由器需要记住所有MAC地址在哪个子网，会花费极多的内存空间，无法实现。
  3. 每个子网的设备，对应IP地址的前缀都是一样的， 路由器只需要通过IP地址的前缀就可以知道设备在哪个子网上。
  总的来说，每个设备的IP地址可以看出收件地址，而MAC地址则为收件人， 缺一不可。 

先介绍数据传输的过程：

* 总的来说，是从高层传到底层，在通信链路上传输。
* 传输层的TCP报文在网络层封装成IP数据报， 在数据链路层封装成MAC帧， 然后在通信链路中传输。
* MAC帧在传送时的源地址和目的地址都是MAC地址，通信链路中的主机或路由器都是根据MAC帧首部的MAC地址接收MAC帧。
* 数据链路层看不到IP地址，只有当数据从链路层传到网络层时，去除MAC帧的首部和尾部才能在IP数据包的首部中找到源IP地址和目的地址。
* 在数据传输过程中，会遇到多个路由器，但是IP数据包的源地址和目的地址是一直不变的，但是MAC地址会随着链路的改变而改变。

ARP的工作流程：

主机A向主机B发送IP数据报

1. 主机A和主机B在同一个局域网内：
   * 主机A的ARP缓存表中查找到主机B的IP地址和对应的MAC地址，将MAC地址写入到MAC帧的首部，发送。
   * 没有查找到， 就会在局域网内广播一个ARP请求分组，主机B在请求分组中发现有自己的IP地址， 向主机A单独发送一个带有自己MAC地址的响应分组。 A收到响应分组，会在ARP缓存表中写入数据。然后发送IP数据报。

2. 不在同一个局域网内：
   * 知道主机B的MAC地址也无法直接通信。必须通过路由器进行转发到主机B的局域网内，再通过主机B的MAC地址找到主机B。且主机A的ARP缓存表中主机B的IP地址对应的是通信链路上的下一跳路由器的MAC地址。
   * 不知道MAC地址时，需要进行多次广播ARP请求分组，找到对应的路由MAC地址，最终找到主机B的MAC地址，建立通信链路。


### 6. URI和URL的区别

* URI：统一资源标志符，主要作用是唯一标识一个资源。

* URL：统一资源定位符，主要作用是提供资源的路径。

### 7. DNS

* DNS域名系统。

* 集群式的工作方式。

* DNS的工作流程：

  主机向本地域名服务器的查询一般是递归查询，本地域名服务器向根域名的查询一般是采用迭代查询

  1. 浏览器输入网址，先检查本地hosts文件是否有这个域名的映射关系，有完成调用IP，完成解析

  2. 没有，查询本地DNS解析器缓存

  3. 没有，查找本地DNS服务器

  4. 没有，本地DNS服务器向根域名服务器发起查询请求，根域名服务器会告诉本地域名服务器去查询哪个顶级域名服务器

  5. 顶级域名服务器

  6. 权限域名服务器

  7. 获得对应的IP地址 完成解析

### 8. ping的过程

ping是ICMP（网络层协议）的一个重要应用。ping的作用是测试两个主机的连通性。

工作过程：

* 向目的主机发送多个ICMP回送请求报文。

* 根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包往返时间及丢包率。

### 9. TCP与UDP的区别

* TCP：面向连接  可靠  字节流传输   速度慢    资源消耗多    文件/邮件传输   头部（源端口 目的端口 序号 确认号 校验和  窗口）
* UDP：无连接   不可靠    数据报文段   速度快   资源消耗少   视频/语音传输    头部（源端口 目的端口 长度 校验和）
* TCP保证可靠传输的方式：
  1. 校验和：
  
     在发送端和接收端分别计算数据的校验和，不一致将丢弃
  
  2. 序列号：
  
     TCP会对每一个发送的字节进行编号，接收方收到数据后，会对发送方 发送确认应答（ACK报文），这个报文中带有相应的确认编号，告诉发送方下一次发送的数据编号。
  
  3. 超时重传：
  
     发送方在一定时间内没有收到确认序号ACK，就会重发数据。再次发送还是没有应答，等待时间就会以2的指数增长，直到连接关闭。
  
  4. 流量控制：
  
     如果数据发送太快，会出现丢包问题。TCP使用滑动窗口进行流量控制，TCP首部有个16字段的窗口，大小是接收端接收数据缓冲区的剩余大小。接收端发送ACK报文时，会将自己的窗口大小填入，发送端会根据接收端窗口的大小控制发送速度。
  
  5. 拥塞控制：
  
     网络发生拥塞，出现丢包问题时， 发送端继续发送丢失的数据包，会加重网络拥塞。
  
     包括四个部分：慢开始、拥塞避免、快重传和快恢复。
  
     * 慢开始：设置拥塞窗口的状态量初始值为1，收到ACK后，变为2，呈指数增长。
     * 拥塞避免：设置临界值，大于临界值，每次只增长1。当网络超时，临界值变为一半。
     * 快重传：丢包时，接收方可以什么都不做，也可以发送多次上次传输的确认报文，使发送方无需等待重传计时器设置的时间，直接重传。
     * 快恢复： 快重传之后，临界值会设定为快重传时状态量的一半，状态量会设定为临界值，开始拥塞避免。

### 10. HTTP和HTTPS的区别

* HTTP：端口80  无加密   不需要证书   运行在TCP协议上
* HTTPS：端口443  有加密  需要证书   运行在SSL协议之上  SSL协议运行在TCP协议上

* 对称加密：

  加密和解密使用的是用一套密钥， 存在无法安全将密钥传输给另一方。

* 非对称加密：

  加密和解密使用的是不同的密钥， 一把公开的密钥， 一把私有的密钥。

  A生成一对非对称密钥，将公钥进行公开， 而B也生成了一对非对称密钥， B使用A发布的公钥对自己的公钥进行加密并发送给A， A使用自己的私钥进行解密， 获得B的公钥。A和B双方使用对方的公钥加密和发送消息，再用自己的私钥进行解密，实现安全的通信。

  
### 11. HTTPS的加密过程

结合对称加密和非对称加密的混合加密算法。使用非对称加密来传输对称密钥保证安全性，使用对称加密保证通信的效率。

基本流程是：服务端生成一对非对称密钥，将公钥发送给客户端、客户端生成对称密钥，使用服务端发来的公钥进行加密，发送给服务端。服务端使用私钥进行解密，得到客户端的对称密钥。双方使用对称密钥进行安全通信。

但是客户端无法判断收到的公钥是服务端发送来的。这时候需要证书。

改进后的过程：

1. 客户端向服务端发起第一次握手请求，告诉服务端 自己支持的SSL版本、加密算法和密钥长度等。
2. 服务端将自己的公钥发送给数字认证机构， 数字认证机构使用自己的私钥对服务端的公钥进行数字签名，并给服务器颁发公钥证书。
3. 服务端将证书发给客户端。
4. 客户端利用数字认证机构的公钥，验证证书的数字签名，确保服务器的公钥的真实性。
5. 客户端使用服务端的公钥加密自己生成的对称密钥，发送给服务端。
6. 服务端使用私钥解密信息，获得客户端的对称密钥。
7. 通信双方使用对称密钥进行加密解密信息。

### 12. 常用的HTTP方法

* PUT：上传文件，向服务器添加数据， 可以看成增

* DELETE：删除文件

* POST：传输数据， 向服务器提交数据， 对服务器数据进行更新

* GET：获取资源， 查询服务器资源

  GET的参数放在URL中，POST的参数存储在实体主体中， GET的安全性较差。GET具有幂等性。

### 13. Session、Cookie、Token

http协议是无状态的，服务器无法判断用户身份。Session、Cookie和Token都可以进行身份认证。

https://blog.csdn.net/whl190412/article/details/90024671

### 14. 浏览器输入url到显示主页的过程

* 输入到浏览器的url进行DNS解析， 将域名转换为IP地址
* 使用IP地址 和目的服务器建立TCP连接
* 向目的服务器发送http请求
* 服务器处理请求并返回HTTP报文
* 浏览器解析并渲染页面

