# 操作系统 知识系统

##  操作系统简介

###  1. 什么是操作系统

* 操作系统是管理计算机资源和进程、硬件和软件的一种应用程序，是计算机中最重要的一个软件。

* 是软件和硬件的中间层，分离软硬件，使我们开发的重心更多放在软件实现，而不是硬件。

* 操作系统管理着程序和内存，CPU的交互。

它的作用或者目的：
* 管理计算机资源：CPU、内存、磁盘等

* 为用户提供图形化界面

* 为软件提供服务，分配给软件运行时的必要资源

主要功能：

* 进程管理：进程任务调度

* 内存管理：管内存的分配和回收

* 设备管理：对设备进行分配，使设备与主机并行工作

* 文件管理：管理文件的存储空间，组织和管理文件系统

* 提供用户接口：提供了访问硬件的接口，使用户通过应用程序发起系统调用操控硬件

结构：

* 单体系统
* 分层系统
* 微内核：运行在内核态，其余模块可以作为普通用户进程运行
* 客户-服务器模式


### 2.   Linux系统应用程序不能直接在Windows下运行

* linux可执行文件格式是elf  windows可执行程序是PE格式

* linux的API叫系统调用，是通过软中断实现。 windows的API是放在动态链接库（dll）中。

* 两者获取系统资源方式不一样

### 3. 什么是内核

* 内核：是一个计算机程序，是操作系统的核心，可以控制操作系统中所有的内容。是boot loader装载程序之前加载的第一个程序。

* boot loader：引导加载程序，将计算机的操作系统放入内存。在电源通电或计算机重启时，BIOS会执行一些初始测试，将控制权转移到引导加载程序所在的主引导记录。

用户态和内核态时操作系统的两种运行状态。

* 内核态：处于内核态的CPU可以访问任意数据，可以切换程序，不会发生抢占情况，处于特权级0
* 用户态：处于用户态的CPU只能访问受限的内存，不允许访问外围设备，CPU不允许独占。

计算机中有些操作：设置时钟、内存清理都需要在内核态下完成。  

 **用户态与内核态的切换**

* 当用户程序需要从硬盘读取数据、从键盘获取数据时，需要从用户态切换内核态，获取完数据后，需要转换回来。

  模式转换只有系统调用才完成，能够执行系统调用的只有操作系统。

  一般使用中断指令 从用户态转换为内核态。

### 4. 实时系统

实时操作系统有两种：硬实时和软实时

* 硬实时：

  规定某个动作必须在规定的时刻内完成，否在会造成永久性伤害。例如汽车生产空间

* 软实时：

  可接受偶尔的违反时限要求，且不会引起任何永久性伤害。例如多媒体、手机
### 5. Linux操作系统的启动过程

1. BIOS开机自检，对硬件进行检测和初始化。

2. 自检完成，磁盘第一个分区MBR（主引导记录），读入到boot程序所在内存区域。为操作系统释放内存。

3. boot读取启动设备的根目录，理解文件系统和目录格式。boot程序被调入内核，控制权交给内核。

4. 启动内核：创建内核堆栈、识别CPU类型、计算内存、禁用终端、启动内存管理单元。调用main函数执行操作系统部分

5. 操作系统配置硬件，之后

## 进程和线程

### 1. 进程、线程和区别

进程是正在运行的程序的实例，线程就是进程中的某条流向。浏览器如果为一个进程的话，每个Tab页可以看作成一个线程。

* 线程之间会共享数据，进程具有很强的独立性。
* 创建线程的开销很小，仅需要堆栈指针和程序计数器，创建进程需要操作系统分配新的地址空间和数据资源。

**上下文切换**：将CPU资源从一个进程分配给另一个进程的机制。切换过程中，操作系统需要先存储当前进程的状态（内存空间的指针，执行完的指令），再读入下一个进程的状态，然后执行该进程。

### 2. 进程间的通信方式

两个或多个线程同时对一个共享数据进行修改，从而影响程序运行的正确性，称为**竞技状态**

解决竞技状态，需要设置临界区。

**进程间的通信**：

* 消息传递：是进程间实现通信和同步等待的机制，进程间的交流不需要共享变量，发送方和接收方进行直接通信。
  1. 管道：用于两个相关进程之间的通信，半双工通信，实现全双工 需要再加一个管道
  2. 消息队列：内核中存储消息的链表，由消息队列标识符进行标识，在不同的进程之间提供全双工的通信连接
  3. 先进先出队列：用于两个不相关进程的通信  全双工通信
* 直接通信：进程和进程之间只存在一条链路，进程间要明确双方的命名
* 间接通信：中介者用于存放消息，达到进程间通信
* 共享内存：使用所有进程之间的内存来建立连接，需要同步进程访问来相互保护

### 3. 进程状态

1. 运行态：进程实际占用CPU时间片运行时

2. 就绪态：进程可运行，但因为其他进程正在运行而处于就绪状态

3. 阻塞态：进程不具备运行条件，正在等待被CPU调度

<img src="D:\Myleetcode\图片\微信截图_20210708200145.png" style="zoom:80%;" />

<img src="D:\Myleetcode\图片\微信截图_20210708200351.png" style="zoom:80%;" />

**调度算法**：三大类：批处理中的调度、交互系统中的调度、实时系统中的调度

**批处理中的调度：**

* 先来先服务：维护一个队列，就绪的进程会在队列尾部插入，运行的进程阻塞或者时间片到时，头部的进程就会开始运行

* 短作业优先：周转时间=运行时间+等待时间  该算法的思想就是让时间最短的进程先执行 这样每个进程的平均周转时间就是最小的。但是只有当所有的进程都能运行的情况下，短作业优先算法 才是最优的。

* 最短剩余时间优先： 基本上是可抢占版的短作业优先，当新作业达到时，其整个时间与当前进程的剩余时间比较，如果小的话，就会运行新的进程

**交互系统中的调度：** 在生活中比较常见

* 时间片轮转算法：给每个进程都分配了一个相同的时间片，超过时间片的进程就会被挂起，CPU会分配给下一个进程。如果在时间片内进程阻塞或者执行完毕，直接运行下个进程。
* 优先级调度算法：按照优先级运行进程，调度程序会在每个时钟周期降低当前运行进程的优先级，如果当前运行的进程优先级降低到下一个进程的优先级以下，就会发生进程切换。
* 最短进程优先：无法确定进程的运行时间，需要根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。 
* 彩票调度：当做出一个调度决策时，随机抽出一张彩票，拥有彩票的进程将获得资源
* 公平分享调度：调度之前会把进程的拥有者考虑在内，无论一个用户有多少个进程，都将获得相同的CPU资源

## 死锁

### 1. 僵尸进程

已完成且处于终止状态，但仍然在进程表中的进程。一般发生在父子关系的进程中，父进程仍需要读取其子进程的退出状态所导致。

### 2. 死锁的产生

在两个或两个以上的并发进程中，每个进程持有资源而又等待其他进程释放的资源，未改变这个状态之前都不无法推进，就是死锁。多个进程之间无限期的阻塞、相互等待的状态。

**原因：**资源竞争和程序执行顺序不当

**必要条件：**

* 互斥：每个资源都被分配到了一个进程
* 占有并等待：已分配到资源的进程可以申请新的资源
* 循环等待：系统中一定有两个或两个以上的进程组成一个循环，每个进程都在等待下一个进程释放的资源
* 非抢占：分配给一个进程的资源只能由当前进程释放，不能被其他进程抢占

### 3. 预防死锁

* 破坏互斥：资源不会被一个进程独占
* 破坏占有并等待：所有进程在执行之前请求全部的资源，但无法知道一个进程在执行完成之前到底需要多少资源；还有就是当一个进程需要请求资源时，释放掉所占有资源，再尝试一次获取全部资源
* 破坏循环等待：制定标准，一个进程在任何时候只能使用一种资源，需要使用另一个资源，必须释放当前资源
* 破坏非抢占：虚拟化方式避免

### 4. 死锁解除

* 通过抢占恢复：临时将某个资源从持有者转移到另一个进程，使用完后又送回。简单粗暴，不可取

* 回滚：定期检查进程，进程的检查点意味进程的状态可以被写入到文件以便后面进行恢复。检测点一般包含存储映像和资源状态。

* 杀死一个进程

## 内存管理

### 1. 虚拟地址

为了避免两个进程使用相同的绝对物理地址，操作系统为每个进程分配独立的一套虚拟地址。

且提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。

* 程序所使用的内存地址叫做**虚拟内存地址**

* 实际存在硬件里面的空间地址叫做**物理内存地址**

进程的虚拟地址通过CPU中的内存管理单元MMU的映射关系，转换编程物理地址，再通过物理地址访问内存。

**如何管理虚拟地址和物理地址之间的关系**

* 内存分段：

  因为程序是由若干个逻辑分段组成的，如代码分段、数据分段、栈段和堆段。不同的段有不同的属性，从而用分段的形式把这些段分离出来。

  虚拟地址通过段表与物理地址进行映射，程序中的四个段在段表中都有对应的项， 每个项里有对应的段基地址和段界限。映射时，在对应的项里找到段基地址加上偏移量，就得到了对应的物理内存地址。

  **缺点**：

  * 内存碎片

    1. 外部内存碎片，产生了多个不连续的小物理内存，导致新的程序无法被加载。
    2. 内部内存碎片，程序所有的内存都被装载到了物理内存，造成内存资源浪费

  * 内存交换效率低

    解决外部内存碎片的方法是内存交换，分段方式很容易产生内存碎片，每次都需要重新swap内存区域，将内存的数据写到硬盘上，硬盘速度远远低于内存，如果程序数据非常大的话，就会造成机器卡顿。

    

* 内存分页：

  为了解决内存分段产生的外部内存碎片和内存交换效率低的问题，才出现了内存分页。

  分页就是把虚拟和物理内存空间切成一段段固定尺寸的大小，每一段称为页，linux下每一页的大小为4KB。

  虚拟地址使用页表与物理地址进行映射。

  页表存储在CPU的内存管理单元（MMU）中。

  * 当进程访问的虚拟地址在页表中查不到时，系统会报出一个缺页异常，然后进入系统内核空间分配物理内存、更新进程页表，最后返回用户空间，恢复进程的运行。

  * 虚拟内存地址到物理内存地址的转换：

    1. 虚拟内存地址分为页号和偏移量。

    2. 根据页号从页表中取得对应的物理页号。

    3. 用物理页号和页内偏移量，得到物理内存地址。

       ![](D:\Myleetcode\图片\微信截图_20210715120306.png)
    
  * 解决页表过大的问题：

    1. 多级页表

       多级页表解决空间上的问题，但是多级转换的过程带来了时间上的开销。

    2. TLB（快表）

       根据程序的局部性原则，把最常访问的几个页表存储到cache中，也就是快表。CPU寻址时先通过MMU访问TLB，如果没找到，继续查找常规的页表。

  分页中的内存交换：

  * 当物理内存空间不足时，操作系统会将其他正在运行的进程中最近没被使用的内存页面释放，暂时写在硬盘上，等需要使用的时候，再从硬盘读到内存中。 一次性写入到硬盘中的页面较少，内存交换的效率较高。
  * 而且分页的方式使得程序运行的时候，无需全部加载到物理内存上，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里，减少不必要的内存资源浪费。

  

  ​     <img src="D:\Myleetcode\图片\微信截图_20210715115443.png" style="zoom:80%;" />

  

  * 页面置换算法：

    进程运行的过程中，若访问的页面不存在内存中，就会发生缺页中断。内存中没有空闲的页面，操作系统需要在内存中选择一个页面移除，再将需要访问的页面调入内存中。这个过程就叫页面置换算法。

    1. OPT最佳置换算法

       这个算法需要知道未来需要调用的页面，每次淘汰的页面为以后最长时间内不再被访问的页面。

    2. FIFO先进先出算法

       最简单的置换算法，每次需要淘汰页面时，将头页面弹出即可。

    3. LRU最近最久未使用算法

       这个算法每次淘汰的页面是最近最久未使用的页面。 需要记录每个页面上次被访问以来经历的时间t。

    4. LFU最近最少使用算法

       淘汰的页面是最近访问次数最少的页面，最近时间需要设定，LFU是基于访问次数，而LRU是基于访问时间

* 段页式内存管理：

  1. 先将程序划分为多个有逻辑意义的段

  2. 再把每个段划分为多个固定大小的页

  * 虚拟地址则由段号、段内页号和页内偏移 三个部分组成。
  * 三次内存访问：
    1. 第一次访问段表，得到页表起始地址
    2. 第二次访问页表，得到物理页号
    3. 第三次将物理页号和页内偏移组合，得到物理内存地址

  

### 2.Linux内存管理方式

**Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理**。于是 Linux 就把所有段的基地址设为 `0`，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。

